#!/usr/bin/env bash

set -e

old_nullglob_setting="$(shopt -p nullglob 2>/dev/null || true)"
shopt -s nullglob

CONFIG_DIR="$HOME/.config/mkproj"
TEMPLATES_DIR="$CONFIG_DIR/templates"
BIN_DIR="$HOME/.local/bin"
mkdir -p "$CONFIG_DIR/templates" "$BIN_DIR"
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_REPO="https://github.com/SadDevastator/mkproj.git"

RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
BOLD="\033[1m"
RESET="\033[0m"

info() { printf "%b\n" "${BLUE}${1}${RESET}"; }
success() { printf "%b\n" "${GREEN}${1}${RESET}"; }
warn() { printf "%b\n" "${YELLOW}${1}${RESET}"; }
err() { printf "%b\n" "${RED}${1}${RESET}"; }

load_deps() {
    local tmpl="$1"
        info "Updating templates..."
        mkdir -p "$TEMPLATES_DIR"

        # If the templates dir is a git repo, try to pull first
        if [[ -d "$TEMPLATES_DIR/.git" ]]; then
            git -C "$TEMPLATES_DIR" pull -q || warn "git pull in templates repo failed"
            success "Templates updated from git"
        fi

        # Determine which repo to use for templates: env override or default repo
        repo_to_clone="${MKPROJ_TEMPLATES_REPO:-$DEFAULT_REPO}"
        if [[ -n "$repo_to_clone" ]]; then
            if command -v git &>/dev/null; then
                tmpdir=$(mktemp -d)
                if git clone --depth 1 "$repo_to_clone" "$tmpdir"; then
                    # If the cloned repo contains a templates/ folder, install those
                    if [[ -d "$tmpdir/templates" ]]; then
                        for d in "$tmpdir/templates"/*; do
                            [[ -d "$d" ]] || continue
                            base="$(basename "$d")"
                            rm -rf "$TEMPLATES_DIR/$base"
                            cp -a "$d" "$TEMPLATES_DIR/" 2>/dev/null || cp -r "$d" "$TEMPLATES_DIR/" 2>/dev/null || true
                            success "Reinstalled template from repo: $base"
                        done
                        success "Templates cloned and reinstalled from $repo_to_clone"
                    else
                        warn "Cloned repo $repo_to_clone but no templates/ directory found inside it"
                    fi
                    rm -rf "$tmpdir"
                else
                    warn "Failed to clone $repo_to_clone"
                    rm -rf "$tmpdir"
                fi
            else
                warn "git not available; cannot clone templates from $repo_to_clone"
            fi
        fi

        # Reinstall bundled templates by overwriting existing user templates
        if [[ -d "$script_dir/templates" ]]; then
            for d in "$script_dir/templates"/*; do
                [[ -d "$d" ]] || continue
                base="$(basename "$d")"
                rm -rf "$TEMPLATES_DIR/$base"
                cp -a "$d" "$TEMPLATES_DIR/" 2>/dev/null || cp -r "$d" "$TEMPLATES_DIR/" 2>/dev/null || true
                success "Reinstalled bundled template: $base"
            done
            success "Bundled templates reinstalled into $TEMPLATES_DIR"
            return 0
        fi

        warn "No bundled templates found and no MKPROJ_TEMPLATES_REPO set. Nothing to reinstall."
    eval "$old_nullglob_setting"
fi


find_config_sh() {
    local tmpl="$1"
    local confdir="$CONFIG_DIR/config"
    local variant
    for variant in "${tmpl^^}" "${tmpl^}" "${tmpl,,}"; do
        if [[ -f "$confdir/${variant}.sh" ]]; then
            printf "%s" "$confdir/${variant}.sh"
            return 0
        fi
    done
    for variant in "${tmpl^^}" "${tmpl^}" "${tmpl,,}"; do
        if [[ -f "$script_dir/config/${variant}.sh" ]]; then
            printf "%s" "$script_dir/config/${variant}.sh"
            return 0
        fi
    done
    return 1
}

source_config_module() {
    local tmpl="$1"
    local cfg
    if cfg="$(find_config_sh "$tmpl")"; then
        . "$cfg"
        return 0
    fi
    return 1
}

usage() {
    echo "Usage:"
    echo "  mkproj create <project-name> <template-name> [--auto-install] [--git] [--code|-C] [--dir <path>]"
    echo "  mkproj add-template <source-folder|-> <template-name> [--script <script-path>] [--dependencies \"k=v[,k2=v2...]\"]"
    echo "  mkproj remove-template <template-name>"
    echo "  mkproj update-dependancies <template-name> \"k=v[,k2=v2...]\""
    echo "  mkproj update-templates"
    echo "  mkproj update"
    echo "  mkproj list-templates"
    exit 1
}

update_templates() {
    info "Updating templates..."
    if [[ -d "$TEMPLATES_DIR/.git" ]]; then
        git -C "$TEMPLATES_DIR" pull -q || true
        success "Templates updated from git"
        return 0
    fi

    if [[ -n "$MKPROJ_TEMPLATES_REPO" ]]; then
        if ! command -v git &>/dev/null; then
            warn "git not available; cannot clone templates from $MKPROJ_TEMPLATES_REPO"
        else
            tmpdir=$(mktemp -d)
            if git clone --depth 1 "$MKPROJ_TEMPLATES_REPO" "$tmpdir"; then
                mkdir -p "$TEMPLATES_DIR"
                cp -a "$tmpdir/." "$TEMPLATES_DIR/" 2>/dev/null || cp -r "$tmpdir/." "$TEMPLATES_DIR/" 2>/dev/null || true
                rm -rf "$tmpdir"
                success "Cloned templates from $MKPROJ_TEMPLATES_REPO into $TEMPLATES_DIR"
                return 0
            else
                warn "Failed to clone $MKPROJ_TEMPLATES_REPO"
                rm -rf "$tmpdir"
            fi
        fi
    fi

    if [[ -d "$script_dir/templates" ]]; then
        mkdir -p "$TEMPLATES_DIR"
        for d in "$script_dir/templates"/*; do
            [[ -d "$d" ]] || continue
            base="$(basename "$d")"
            if [[ -e "$TEMPLATES_DIR/$base" ]]; then
                info "User template '$base' already exists, skipping"
            else
                cp -a "$d" "$TEMPLATES_DIR/" 2>/dev/null || cp -r "$d" "$TEMPLATES_DIR/" 2>/dev/null || true
                success "Installed bundled template: $base"
            fi
        done
        success "Bundled templates seeded into $TEMPLATES_DIR"
        return 0
    fi

    warn "No git repo for templates, no bundled templates found, and no MKPROJ_TEMPLATES_REPO set. Add templates manually."
}

update_self() {
    info "Updating mkproj tool..."
    if [[ -d "$script_dir/.git" ]]; then
        git -C "$script_dir" pull --ff-only || warn "git pull failed (non-fatal)"
        success "Updated mkproj in-place from git repository."
        return 0
    fi

    local DEFAULT_REPO="https://github.com/SadDevastator/mkproj.git"
    if ! command -v git &>/dev/null; then
        err "git is required to update mkproj when not installed from a git checkout."
        return 1
    fi

    local tmpdir
    tmpdir=$(mktemp -d)
    if git clone --depth 1 "$DEFAULT_REPO" "$tmpdir"; then
        if [[ -f "$tmpdir/mkproj" ]]; then
            cp "$tmpdir/mkproj" "$BIN_DIR/mkproj" && chmod +x "$BIN_DIR/mkproj"
            success "Reinstalled mkproj from $DEFAULT_REPO to $BIN_DIR/mkproj"
        else
            err "Cloned repo did not contain mkproj script."
            rm -rf "$tmpdir"
            return 1
        fi
    else
        err "Failed to clone $DEFAULT_REPO"
        rm -rf "$tmpdir"
        return 1
    fi
    rm -rf "$tmpdir"
}

list_templates() {
    [[ ! -d "$TEMPLATES_DIR" ]] && update_templates
    info "Available templates:" 
    if [[ -d "$TEMPLATES_DIR" ]]; then
        for d in "$TEMPLATES_DIR"/*; do
            [[ -d "$d" ]] || continue
            echo "  $(basename "$d")"
        done
    fi
    if [[ -d "$script_dir/templates" ]]; then
        info "--- bundled ---"
        for d in "$script_dir/templates"/*; do
            [[ -d "$d" ]] || continue
            echo "  $(basename "$d")"
        done
    fi
}


find_template() {
    local tmpl="$1"
    local lc="${tmpl,,}"
    local d base

    if [[ -d "$TEMPLATES_DIR" ]]; then
        for d in "$TEMPLATES_DIR"/*; do
            [[ -d "$d" ]] || continue
            base="$(basename "$d")"
            if [[ "${base,,}" == "$lc" ]]; then
                echo "$d"
                return 0
            fi
        done
    fi

    if [[ -d "$script_dir/templates" ]]; then
        for d in "$script_dir/templates"/*; do
            [[ -d "$d" ]] || continue
            base="$(basename "$d")"
            if [[ "${base,,}" == "$lc" ]]; then
                echo "$d"
                return 0
            fi
        done
    fi

    return 1
}


detect_pkgmgr() {
    local pkgmanagers=("apt" "dnf" "pacman" "zypper" "apk" "xbps-install")
    for mgr in "${pkgmanagers[@]}"; do
        if command -v "$mgr" &>/dev/null; then
            echo "$mgr"
            return
        fi
    done
    echo "unknown"
}


install_missing() {
    local tmpl="$1"
    load_deps "$tmpl"

    local -n depmap="DEPS_${tmpl^^}"
    local missing=()
    for dep in "${!depmap[@]}"; do
        command -v "$dep" &>/dev/null || missing+=("${depmap[$dep]}")
    done

    if [[ ${#missing[@]} -eq 0 ]]; then
        echo "All dependencies installed."
        return
    fi

    warn "Missing dependencies: ${missing[*]}"

    declare -a pkgmgrs=()
    for candidate in apt dnf pacman zypper apk xbps-install; do
        command -v "$candidate" &>/dev/null && pkgmgrs+=("$candidate")
    done

    primary=$(detect_pkgmgr)

    echo
    info "Available package managers:"
    idx=1
    for mgr in "${pkgmgrs[@]}"; do
        if [[ "$mgr" == "$primary" ]]; then
            echo "  $idx) $mgr (primary)"
        else
            echo "  $idx) $mgr"
        fi
        ((idx++))
    done
    echo "  $idx) none (skip installation)"
    read -p "Choose package manager [$idx]: " choice
    choice=${choice:-$idx}

    if [[ "$choice" -lt "$idx" ]]; then
        selected="${pkgmgrs[$((choice-1))]}"
        info "Installing using $selected..."
        case "$selected" in
            apt)
                sudo apt install -y "${missing[@]}" ;;
            dnf)
                sudo dnf install -y "${missing[@]}" ;;
            pacman)
                sudo pacman -S --noconfirm "${missing[@]}" ;;
            zypper)
                sudo zypper install -y "${missing[@]}" ;;
            apk)
                sudo apk add "${missing[@]}" ;;
            xbps-install)
                sudo xbps-install -y "${missing[@]}" ;;
        esac
    else
        warn "Skipping installation. You may install dependencies manually later."
    fi
}


create_project() {
    local name="$1" tmpl="$2"
    shift 2
    local auto_install=0 git_init=0 open_code=0 update_only=0

    local target_dir
    target_dir="$(pwd)"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --auto-install)
                auto_install=1
                shift
                ;;
            --update)
                update_only=1
                shift
                ;;
            --git)
                git_init=1
                shift
                ;;
            --code|-C)
                open_code=1
                shift
                ;;
            --dir)
                target_dir="$2"
                shift 2
                ;;
            --dir=*)
                target_dir="${1#*=}"
                shift
                ;;
            --*)
                echo "Unknown option: $1"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    [[ -z "$name" || -z "$tmpl" ]] && usage

    if tmpl_dir="$(find_template "$tmpl")"; then
        info "Using template: $tmpl_dir"
        ((auto_install)) && install_missing "$tmpl"

        local dest="$target_dir/$name"
        if [[ -d "$dest" && $update_only -ne 1 ]]; then
            err "Destination '$dest' already exists. Use --update to update an existing project."
            exit 1
        fi

        mkdir -p "$dest"
        cp -r "$tmpl_dir/." "$dest/"
        find "$dest" -type f -exec sed -i "s/{{PROJECT_NAME}}/$name/g" {} + 2>/dev/null || true

        source_config_module "$tmpl" || true

        local create_fn="mkproj_create_${tmpl,,}"
        if declare -F "$create_fn" >/dev/null 2>&1; then
            info "Running template create hook function: $create_fn"
            (cd "$dest" && PROJECT_NAME="$name" PROJECT_DIR="$dest" "$create_fn" "$name" "$dest") || true
        elif [[ -f "$dest/create.sh" ]]; then
            info "Running template create hook in $dest..."
            (cd "$dest" && PROJECT_NAME="$name" PROJECT_DIR="$dest" "$SHELL" "./create.sh") || true
        fi
        if [[ -d "$dest" && $update_only -eq 1 ]]; then
            local update_fn="mkproj_update_${tmpl,,}"
            if declare -F "$update_fn" >/dev/null 2>&1; then
                info "Running template update hook function: $update_fn"
                (cd "$dest" && PROJECT_NAME="$name" PROJECT_DIR="$dest" "$update_fn" "$name" "$dest") || true
            elif [[ -f "$dest/update.sh" ]]; then
                info "Running template update hook in $dest..."
                (cd "$dest" && PROJECT_NAME="$name" PROJECT_DIR="$dest" "$SHELL" "./update.sh") || true
            fi
        fi
    else
        source_config_module "$tmpl" || true

        local create_fn="mkproj_create_${tmpl,,}"
        if declare -F "$create_fn" >/dev/null 2>&1; then
            info "Running bundled create function: $create_fn"
            (cd "$target_dir" && PROJECT_NAME="$name" PROJECT_DIR="$target_dir" "$create_fn" "$name" "$target_dir") || true
        else
            err "Unsupported template: $tmpl"
            list_templates
            exit 1
        fi
    fi
    ((git_init)) && git -C "$name" init -q && echo "ðŸ“¦ Git initialized"

    ((open_code)) && command -v code &>/dev/null && code "$name"

    echo "Project '$name' ($tmpl) created successfully!"
}


add_template() {
    local src="$1" tmpl="$2"
    shift 2 || true
    local deps_arg="" script_arg=""
    local force=0

    [[ -z "$tmpl" ]] && { echo "Usage: mkproj add-template <source-folder|-> <template-name> [--script <script-path>] [--dependencies \"k=v[,k2=v2...]\"]"; exit 1; }

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dependencies|--dependancies)
                deps_arg="$2"
                shift 2
                ;;
            --dependencies=*)
                deps_arg="${1#*=}"
                shift
                ;;
            --dependancies=*)
                deps_arg="${1#*=}"
                shift
                ;;
            --script)
                script_arg="$2"
                shift 2
                ;;
            --script=*)
                script_arg="${1#*=}"
                shift
                ;;
            --force|-f)
                force=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                shift
                ;;
        esac
    done

    if [[ "$src" != "-" && ! -d "$src" ]]; then
        echo "Source folder '$src' does not exist or is not a directory." >&2
        exit 1
    fi

    mkdir -p "$TEMPLATES_DIR"
    local dest="$TEMPLATES_DIR/$tmpl"

    if [[ -e "$dest" ]]; then
        if [[ $force -ne 1 ]]; then
            read -r -p "Template destination '$dest' exists. Overwrite? [y/N]: " ans
            case "$ans" in
                [Yy]*) rm -rf "$dest" ;;
                *) echo "Aborted."; return 1 ;;
            esac
        else
            rm -rf "$dest"
        fi
    fi

    if [[ "$src" != "-" ]]; then
        mkdir -p "$dest"
        cp -a "$src/." "$dest/" 2>/dev/null || cp -r "$src/." "$dest/" 2>/dev/null || cp -r "$src" "$dest" 2>/dev/null
        echo "Template copied to: $dest"
    else
        mkdir -p "$dest"
        echo "Created template folder: $dest (no files, script-only)"
    fi

    if [[ -n "$deps_arg" ]]; then
        mkdir -p "$CONFIG_DIR/config"
        local conf_sh="$CONFIG_DIR/config/${tmpl^^}.sh"
        printf "declare -g -A DEPS_%s\n" "${tmpl^^}" > "$conf_sh"
        local normalized
        normalized="$(echo "$deps_arg" | tr ',' '\n')"
        while IFS= read -r pair; do
            [[ -z "$pair" ]] && continue
            pair="$(echo "$pair" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
            if [[ "$pair" != *=* ]]; then
                echo "Skipping invalid dependency entry: $pair" >&2
                continue
            fi
            key="${pair%%=*}"
            val="${pair#*=}"
            printf "DEPS_%s[\"%s\"]=\"%s\"\n" "${tmpl^^}" "$key" "$val" >> "$conf_sh"
        done <<< "$normalized"
        success "Wrote dependencies to $conf_sh"
    fi

    if [[ -n "$script_arg" ]]; then
        if [[ ! -f "$script_arg" ]]; then
            echo "Script '$script_arg' not found." >&2
            return 1
        fi
        mkdir -p "$dest"
        cp -f "$script_arg" "$dest/create.sh"
        chmod +x "$dest/create.sh"
        success "Installed template script to $dest/create.sh"
    fi

    success "add-template complete. Run 'mkproj list-templates' to verify templates."
}


remove_template() {
    local name="$1"
    [[ -z "$name" ]] && { echo "Usage: mkproj remove-template <template-name>"; exit 1; }

    local force=0

    if [[ "$2" == "--force" || "$2" == "-f" ]]; then
        force=1
    fi

    local target=""
    if [[ -d "$TEMPLATES_DIR/$name" ]]; then
        target="$TEMPLATES_DIR/$name"
    else
        for d in "$TEMPLATES_DIR"/*; do
            [[ -d "$d" ]] || continue
            if [[ "${name,,}" == "$(basename "$d" | tr '[:upper:]' '[:lower:]')" ]]; then
                target="$d"
                break
            fi
        done
    fi

    if [[ -z "$target" ]]; then
        echo "Template '$name' not found in $TEMPLATES_DIR" >&2
        exit 1
    fi

    if [[ $force -ne 1 ]]; then
        read -p "Permanently remove template '$target' and its dependency file? [y/N]: " ans
        case "$ans" in
            [Yy]*) ;;
            *) echo "Aborted."; return 1 ;;
        esac
    fi

    rm -rf "$target"
    echo "Removed template directory: $target"

    local base="$(basename "$target")"
    local conf_sh="$CONFIG_DIR/config/${base^^}.sh"
    local conf_file="$CONFIG_DIR/config/${base^^}.conf"
    if [[ -f "$conf_sh" ]]; then
        rm -f "$conf_sh"
        echo "Removed dependency config: $conf_sh"
    fi
    if [[ -f "$conf_file" ]]; then
        rm -f "$conf_file"
        echo "Removed legacy dependency config: $conf_file"
    fi
}


update_dependancies() {
    local name="$1" deps_arg="$2"
    [[ -z "$name" || -z "$deps_arg" ]] && { echo "Usage: mkproj update-dependancies <template-name> \"k=v[,k2=v2...]\""; exit 1; }

    local tmpl=""
    if [[ -d "$TEMPLATES_DIR/$name" ]]; then
        tmpl="$TEMPLATES_DIR/$name"
    else
        for d in "$TEMPLATES_DIR"/*; do
            [[ -d "$d" ]] || continue
            if [[ "${name,,}" == "$(basename "$d" | tr '[:upper:]' '[:lower:]')" ]]; then
                tmpl="$d"
                break
            fi
        done
    fi

    if [[ -z "$tmpl" ]]; then
        echo "Template '$name' not found in $TEMPLATES_DIR" >&2
        exit 1
    fi

    mkdir -p "$CONFIG_DIR/config"
    local base="$(basename "$tmpl")"
    local conf_file="$CONFIG_DIR/config/${base^^}.conf"
    echo "# Updated by mkproj on $(date -u +%Y-%m-%dT%H:%M:%SZ)" > "$conf_file"
    local normalized
    normalized="$(echo "$deps_arg" | tr ',' '\n')"
    while IFS= read -r pair; do
        [[ -z "$pair" ]] && continue
        pair="$(echo "$pair" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
        if [[ "$pair" != *=* ]]; then
            echo "Skipping invalid dependency entry: $pair" >&2
            continue
        fi
        echo "$pair" >> "$conf_file"
    done <<< "$normalized"
    echo "Wrote dependencies to $conf_file"
}


[[ $# -lt 1 ]] && usage
cmd="$1"; shift

case "$cmd" in
    create)
        create_project "$@"
        ;;
    update)
        update_self && update_templates
        ;;
    add-template)
        add_template "$@"
        ;;
    remove-template)
        remove_template "$@"
        ;;
    update-dependancies)
        update_dependancies "$@"
        ;;
    update-templates)
        update_templates
        ;;
    list-templates)
        list_templates
        ;;
    *)
        usage
        ;;
esac
